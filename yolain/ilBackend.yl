[exports set 'binaryEncode
  [fn [tree acc]
    [def joinResult [acc fails]]
    [set acc [acc or '[]]]
    [acc push [String fromCharCode [tree get 'length]]]
    [if [Array isArray tree]
      [do [acc push '{]
        [tree map [fn [elem] [exports binaryEncode elem acc]]]]
      [do [acc push '"] [acc push tree]]]
    [joinResult and [acc join ""]]]]

[def hasValue [fn [val] [[this.indexOf(val) == -1] fails]]]

[exports set 'toIL
  [fn [ast]
    [def functions '[]]
    [def fnid 0]
    [def compileFunction
      [fn [name args ast]
        [def nextid 0]
        [args set 'hasValue hasValue]
        [def locals '[]]
        [locals set 'hasValue hasValue]
        [def globals '[]]
        [globals set 'hasValue hasValue]
        [def currentFunction '[]]
        [def compileExpression
          [fn [expr withArg]
            [def code '[]]
            [if [Array isArray expr]
              [do [def first [expr get 0]]
                [if [first == '#]
                  [return [compileExpression call null 'undefined withArg]]]
                [if [first == 'set]
                  [do
                    [set code
                      [code concat
                        [compileExpression call null [expr get 2] true]]]
                    [def name [expr get 1]]
                    [if [args hasValue name]
                      [code push [new array 'setArg [expr get 1]]]
                      [if [locals hasValue name]
                        [code push [new array 'setLocal [expr get 1]]]
                        [do [code push [new array 'setGlobal [expr get 1]]]
                          [if [[globals hasValue name] fails]
                            [globals push name]]]]]
                    [if [withArg fails] [code push '[pop]]]
                    [return code]]]
                [if [first == 'def]
                  [do [locals push [expr get 1]]
                    [set code
                      [code concat
                        [compileExpression call null [expr get 2] true]]]
                    [code push [new array 'setLocal [expr get 1]]]
                    [if [withArg fails] [code push '[pop]]]
                    [return code]]]
                [if [first == 'if]
                  [do [def label1 [nextid toString]]
                    [set nextid [nextid + 1]]
                    [def label2 [nextid toString]]
                    [set nextid [nextid + 1]]
                    [set code
                      [code concat
                        [compileExpression call null [expr get 1] true]]]
                    [code push [new array 'jumpIfFalsy label1]]
                    [set code
                      [code concat
                        [compileExpression call null [expr get 2] withArg]]]
                    [code push [new array 'jump label2]]
                    [code push [new array 'label label1]]
                    [set code
                      [code concat
                        [compileExpression call null [expr get 3] withArg]]]
                    [code push [new array 'label label2]]
                    [return code]]]
                [if [first == 'fn]
                  [do [def id ['_ + fnid]]
                    [set fnid [fnid + 1]]
                    [def createdFunction
                      [compileFunction call null id
                        [expr get 1]
                        ['[do] concat [expr slice 2]]]]
                    [functions push createdFunction]
                    [def i 0]
                    [def fnGlobals [createdFunction get 4]]
                    [while [i < [fnGlobals get 'length]]
                        [def globName [fnGlobals get i]]
                        [if [[globals hasValue globName] fails] [globals push globName]]
                        [set i [i + 1]]]
                    [return [new array [new array 'fn id]]]]]
                [if [first == 'do]
                  [do [def i 1]
                    [def length [expr get 'length]]
                    [while [i < length]
                      [set code
                        [code concat
                          [compileExpression call null
                            [expr get i]
                            [[i == [length - 1]] and withArg]]]]
                      [set i [i + 1]]]
                    [return code]]]
                [if true
                  [do [def method [expr get 1]]
                    [set expr [expr slice 1]]
                    [expr set 0 first]
                    [def types [expr map [fn [] 'var]]]
                    [while [0 < [expr get 'length]]
                      [set code
                        [code concat
                          [compileExpression call null [expr pop] true]]]]
                    [def invokeExpr '[invoke]]
                    [invokeExpr push method]
                    [set invokeExpr [invokeExpr concat types]]
                    [code push invokeExpr]
                    [if [withArg fails] [code push '[pop]]]
                    [return code]]]]]
            [if [withArg fails] [return '[]]]
            [# look up var]
            [if [[[parseFloat call null expr] toString] == expr] [return [new array [new array 'num expr]]]]
            [def name expr]
            [if
              [args hasValue name]
              [code push [new array 'getArg name]]
              [if [locals hasValue name]
                [code push [new array 'getLocal name]]
                [do [code push [new array 'getGlobal name]]
                  [if [[globals hasValue name] fails] [globals push name]]]]]
            code]]
        [def code [compileExpression call null [ast slice 0] true]]
        [code push '[return]]
        [currentFunction push name]
        [currentFunction push args]
        [currentFunction push locals]
        [currentFunction push globals]
        [currentFunction push code]
        currentFunction]]
    [functions push [compileFunction call null 'entry '[] ast]]
    functions]]
